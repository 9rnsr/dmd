Ddoc

$(COMMENT Pending changelog for 2.069. This will get copied to dlang.org and
    cleared when master gets merged into stable prior to 2.069.
)

$(BUGSTITLE Compiler Changes,
$(LI $(RELATIVE_LINK2 objective-c-support, Basic support for Objective-C.))
$(LI $(RELATIVE_LINK2 property-switch-deprecated, The $(TT -property) switch has
    been deprecated.))
)

$(BUGSTITLE Language Changes,
$(LI $(RELATIVE_LINK2 template-name-from-inside-instance, Eponymous template name access from inside its instance.))
)

$(BUGSTITLE Compiler Changes,

$(LI $(LNAME2 objective-c-support, Basic support for Objective-C.)

    $(P Basic support for Objective-C classes, interfaces and instance methods.
        This is implemented by adding a new linkage attribute, Objective-C, and
        a compiler recognized UDA, @selector. The linkage attribute is to be
        used on a class or interface. The UDA is attached to a method.
    )
)

$(LI $(LNAME2 property-switch-deprecated, The $(TT -property) switch has
    been deprecated.)

    $(P The $(TT -property) switch used to disallow calling non-properties
        without parentheses. The switch has not been used to build Phobos for
        some time now. So naturally, code that's incompatible with
        $(TT -property) has found its way in. This means, the switch has
        effectively not been supported by D at large.
    )

    $(P Since the behaviour of the $(TT -property) switch was not well-liked,
        it's been deprecated and made to have no effect when used.
    )
)

)

$(BUGSTITLE Language Changes,
$(LI $(LNAME2 template-name-from-inside-instance, Eponymous template name access from inside its instance.)

    ---
    struct Thing(T)
    {
        void instantiationFromInner()
        {
            // 'Thing' refers the innere-most instantiated struct type 'Thing!T'.
            static assert(is(Thing == struct));

            // OK. On the explicit instantiation form, the identifier 'Thing'
            // is treated as the template, because it is inside the template.
            Thing!int t1;

            alias Alias = Thing;
            static assert(is(Alias == struct));

            // Also OK.
            //Alias!int t2;
        }
    }

    template Stuff(alias T)
    {
        void instantiationFromOuter()
        {
            // NG, T is an alias of struct type 'Thing!float',
            // so it cannot be instantiated with !(int)
            // from outside of 'Thing' template.
            T!int var;
        }
    }

    void main()
    {
        alias T = Thing!float;
        alias S = Stuff!(Thing!float);
    }
    ---
)

)

Macros:
    TITLE=Change Log

    BUGSTITLE = <div class="bugsfixed">$(H4 $1) $(OL $2 )</div>

    RELATIVE_LINK2=<a href="#$1">$+</a>
    LNAME2=<a class="anchor" title="Permalink to this section" id="$1" href="#$1">$+</a>

    STDMODREF = <a href="phobos/std_$1.html">$2</a>
    XREF = <a href="phobos/std_$1.html#$2">$2</a>
    CXREF = <a href="phobos/core_$1.html#$2">$2</a>
